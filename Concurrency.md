# 数据库的并发
许多事务对同一数据进行操作

## MySQL 的隔离级别
- 未提交读（READ UNCOMMITTED）
  - 在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为**脏读**。这个级别一般都是理论上存在的，数据库默认的隔离级别一般都是高于该隔离级别的，该级别还会导致不可重读和幻读。
- 提交读（READ COMMITTED）
  - 多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫**不可重复读**，因为两次执行同样的查询可能会得到不同结果。
- 可重复读（REPEATABLE READ）MySQL 默认的隔离级别
  - 可重复读解决了**不可重复读**的问题，保证了在同一个事务中多次读取同样的记录结果一致，换句话说：对方提交之后的数据我还是读不到。但还是无法解决**幻读**，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行：事务 A 读取符合条件的若干行，但是其他事务 B 改变了事务 A 的结果集，导致在事务 A 的结果集的个数增加或者减少。**InnoDB 存储引擎通过多版本并发控制 MVCC 解决幻读的问题**
- 可串行化（SERIALIZABLE）
  - 最高的隔离级别，通过强制**事务串行执行**避免幻读。可串行化会在读取的每一行数据上都**加锁**，事务 A 在操作数据库表中数据的时候，事务 B 只能排队等待，保证每一次读取的都是数据库表中真实的记录，事务 A 和事务 B 不能并发。可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。

## 事务并发访问引起的问题以及如何避免
### 更新丢失 —— MySQL 所有事务隔离级别在数据库层面上均可避免
取款存款问题可能会产生更新丢失

### 脏读 —— 已提交读（READ_COMMITTED）事务隔离级别以上可以避免（Oracle 默认隔离级别）
```sql
select @@tx_isolation;    # 查找当前事务隔离级别
set session transaction isolation level read uncommitted;   # 未提交读隔离级别可能会产生脏读：允许读取未提交的数据
start transaction;        # 开启事务，相当于将自动提交关闭
update account_innodb set balance = 1000 - 100 where id = 1;
select * from account_innodb where id = 1;
# 并未提交，如果此时有别的 session 去读取这个数据，会发生回滚
rollback;
```

### 不可重复读 —— 可重复读（REPEATABLE-READ）事务隔离级别以上可以避免（InnoDB（MySQL）默认）
```sql
select @@tx_isolation; 
start transaction;
select * from account_innodb where id = 1;
```
当 session1 重复读取一个数据，它会读到其他 session 修改并且提交了的值，从上帝视角来看，这是正确的操作；

但是 session1 它本身并不知道是否有别的 session 已经修改这个数据，会使 session1 对自己数据的可靠性产生紊乱

解决方法：
```sql
set session transaction isolation level repeatable read;    # 此时这个 session 的值不随其他 session 的修改而改变，重复读永远是相同的值
# 但是这从逻辑上来说是错误的，需要进行以下修改
update account_innodb set balance = balance - 100 where id = 1;
```

### 幻读 —— 串行（SERIALIZABLE）事务隔离级别可以避免、MySQL 的 InnoDB 也可以避免幻读
session1 在更新的时候，其他 session 进行插入删除操作，session1 此时会发现系统提示更新的行数并不是原先的行数（可能被增加或删除），本来只是想更新 3 条数据，现在变成了更新 4 条数据，显然是错误的

最高的事务隔离级别——串行，会阻塞其他 session 进行插入删除操作

## 解决方法
封锁技术

## 并发策略
并发控制一般采用三种方法，分别是：
- 乐观锁
- 悲观锁
- 时间戳

### 乐观锁
乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据

version 
```sql
# 1.先读取test_innodb的数据，得到 version1d 的值为 VersionValue
select version from test_innodb where id = 2;
# 2.每次更新test_innodb表中的 money 字段得到时候，为了防止发生冲突，先去检查 version 再做更新，更新成功的话 version+1
update test_innodb set money = 123, version = 0 + 1 where version = 0 and id = 2;
```
事务提交之后再去判断，如果发现 version 过期再进行修改

### 悲观锁
悲观锁认为自己读数据库的时候，别人可能刚好在写自己刚读的数据。

所以采用在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据。

或者反过来说，就是**自己修改某条数据的时候，不允许别人读取该数据**，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。

### 时间戳
时间戳就是不加锁，通过时间戳来控制并发出现的问题。

也就是在数据库表中单独加一列时间戳，比如“TimeStamp”，**每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加 1，提交之前，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存**，这种处理方法虽然不使用数据库系统提供的锁机制，但是可以大大提高数据库处理的并发量。

## 数据库锁
- 按锁的粒度划分，可分为表级锁、行级锁、页级锁（介于表和行之间）
- 按锁级别划分，可分为共享锁、排他锁
- 按加锁方式划分，可分为自动锁、显式锁
- 按操作划分，可分为 DML 锁、DDL 锁
- 按使用方式划分，可分为乐观锁、悲观锁

为了保证数据的完整性和一致性，数据库系统采用锁来实现事务的隔离性。

从并发事务锁定的关系上看，可以分为共享锁定和独占锁定；

从锁定的对象不同，一般可以分为表锁定和行锁定

- 共享锁：非独占的，允许其他事务同时读取其锁定的资源，但不允许其他事务更新它，并发性很好
- 独占锁（排他锁）：适用于修改数据的场合。它所锁定的资源，其他事务不能读取也不能修改，并发性最差
- 更新锁：在初始阶段用来锁定可能要被改变的资源，这可以避免使用共享锁造成的死锁

当一个事务访问某种数据库资源时，如果执行 select 语句，必须先获得共享锁；

如果执行 insert、update 或 delete 语句，必须获得独占锁，这些锁用于锁定被操作的资源

当第二个事务也要访问相同的资源时，如果执行 select 语句，也必须先获得共享锁，如果执行 insert、update 或 delete 语句，也必须获得独占锁

此时根据已经旋转在资源上的锁的类型，来决定第二个事务应该等待第一个事务解除对应资源的锁定，还是可以立刻获得锁

| 资源上已经放置的锁 | 第二个事务进行读操作 | 第二个事务进行更新操作 |
| ----------- | ----------- |  ------------|
| 无 | 立即获得共享锁 | 立即获得独占锁 |
| 共享锁 | 立即获得共享锁 | 等待第一个事务解除共享锁 |
| 独占锁 | 等待第一个事务解除独占锁 | 等待第一个事务解除独占锁 |

### 行级锁
可以最大程度地支持并发，同时也带来了最大开销。

**行级锁是一种排他锁，防止其他事务修改此行**；在使用以下语句时，Oracle 会自动应用行级锁：
1. INSERT, UPDATE, DELETE, SELECT...FOR UPDATE[OF columns][WAIT n | NOWAIT];
2. SELECT...FOR UPDATE 语句允许用户一次锁定多条记录进行更新；
3. 使用 COMMIT 或 ROLLBACK 语句释放锁。

**InnoDB 支持事务、行级锁**
```sql
show variables like 'autocommit';
set autocommit = 0;         # 关闭自动提交
```

```sql
select * from person_info_large where id = 3 lock in share mode;   # 加共享锁
commit        # 释放锁
```
```sql
update person_info_large set title = "test3" where id = 3;  
```
一个 session 加了共享锁以后，另一个 session 就不能加排他锁，需要先 commit 释放锁


### 表级锁
最基本的锁策略，并且是开销最小的策略。

表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。

最常使用的 MyISAM 和 InnoDB 都支持表级锁定。

表级锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。

只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。

```sql
select * from person_info_myisam where id between 1 and 2000000;      // 该语句执行的时候会自动加上表级锁
```

```sql
update person_info_myisam set account = account where id = 2000001;   // 该语句需要等上一个语句执行完毕才能执行
```

表级锁定分为表**共享读锁**（共享锁）与表**独占写锁**（排他锁）。

先上读锁，后上读锁/写锁
```sql
select * from person_info_myisam where id between 1 and 2000000;
```
```sql
select * from person_info_myisam where id in (2000000,2000001);
```
第二条 select（读锁） 语句并不会被 block

上了共享锁（读锁）后还能上读锁或者写锁

先上写锁，后上读锁/写锁
```sql
update person_info_myisam set account = account where id between 1 and 2000000;
```
```sql
select * from person_info_myisam where id in (2000001);
```
第二条 select（读锁）语句会被 block

上了排他锁（写锁）后就不能上读锁和写锁

也可给 select 语句上排他锁
```sql
select * from person_info_myisam where id between 1 and 2000000 for update;
```

### 页级锁
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。

表级锁速度快, 但冲突多, 行级锁冲突少, 但速度慢，所以采取了这种的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。

- 表级:引擎 MyISAM, 理解为锁住整个表, 锁定期间, 其它进程无法对该表进行写操作, 如果是读锁, 其他进程可以同时读, 如果是写锁, 则其它进程则读也不允许
- 行级:引擎 InnoDB, 单独的一行记录加锁, 其它进程还是可以对同一个表中的其它记录进行操作
- 页级:引擎 BDB, 表级锁速度快, 但冲突多, 行级冲突少, 但速度慢, 页级折衷, 一次锁定相邻的一组记录

## 锁模块常见面试问题

### MyISAM 与 InnoDB 关于锁方面的区别是什么

- MyISAM 默认用的是表级锁，不支持行级锁（不支持事务）
对数据进行 select 的时候，会自动加上一个表级的读锁；对数据进行增删改的时候，会自动加上一个表级的写锁；当读锁未被释放时另一个 session 想要为表加上一个写锁，此时会被阻塞，直到所有的读锁都被释放为止

```sql
lock table person_info_myisam read;   // 加读锁
unlock tables;                        // 释放读锁
```

- InnoDB 默认用的是行级锁（支持事务），也支持表级锁（不走索引的时候）
行级锁开销比表级锁大

MyISAM 适合的场景
- 频繁执行全表 count 的语句
- 对数据进行增删改的频率不高，查询非常频繁
- 没有事务

InnoDB 适合的场景
- 数据增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

### 数据库事务的四大特性（ACID）
- 原子性（atomicity）
  - 一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。
- 一致性（consisitency）
  - 数据库总是从一个一致性的状态转换到另一个一致性的状态。
- 隔离性（isolation）
  - 针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。
- 持久性（durability）
  - 一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。
  

### 事务隔离级别以及各级别下的并发访问问题

### InnoDB 可重复读隔离级别下如何避免幻读

### RC、RR 级别下的 InnoDB 的非阻塞读如何实现

## 分库分表

### 垂直切分（按照功能模块）
**将表按照功能模块**、关系密切程度划分出来，**部署到不同的库上**。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。

### 水平切分（按照规则划分存储）
当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userId 散列（userId % 2 = 1/0），进行划分，然后存储到多个结构相同的表，和不同的库上。











