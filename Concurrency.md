# 数据库的并发
许多事务对同一数据进行操作

## 带来的问题
- 丢失更新
- 读脏数据
- 死锁（不可重复读）

## 解决方法
封锁技术

## 并发策略
并发控制一般采用三种方法，分别是：
- 乐观锁
- 悲观锁
- 时间戳

### 乐观锁
乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据

### 悲观锁
悲观锁认为自己读数据库的时候，别人可能刚好在写自己刚读的数据。

所以采用在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据。

或者反过来说，就是**自己修改某条数据的时候，不允许别人读取该数据**，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。

### 时间戳
时间戳就是不加锁，通过时间戳来控制并发出现的问题。

也就是在数据库表中单独加一列时间戳，比如“TimeStamp”，**每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加 1，提交之前，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存**，这种处理方法虽然不使用数据库系统提供的锁机制，但是可以大大提高数据库处理的并发量。

## 数据库锁
为了保证数据的完整性和一致性，数据库系统采用锁来实现事务的隔离性。

从并发事务锁定的关系上看，可以分为共享锁定和独占锁定；

从锁定的对象不同，一把吗可以分为表锁定和行锁定

- 共享锁：非独占的，允许其他事务同时读取其锁定的资源，但不允许其他事务更新它，并发性很好
- 独占锁（排他锁）：适用于修改数据的场合。它所锁定的资源，其他事务不能读取也不能修改，并发性最差
- 更新锁：在初始阶段用来锁定可能要被改变的资源，这可以避免使用共享锁造成的死锁

当一个事务访问某种数据库资源时，如果执行 select 语句，必须先获得共享锁；

如果执行 insert、update 或 delete 语句，必须获得独占锁，这些锁用于锁定被操作的资源

当第二个事务也要访问相同的资源时，如果执行 select 语句，也必须先获得共享锁，如果执行 insert、update 或 delete 语句，也必须获得独占锁

此时根据已经旋转在资源上的锁的类型，来决定第二个事务应该等待第一个事务解除对应资源的锁定，还是可以立刻获得锁

| 资源上已经放置的锁 | 第二个事务进行读操作 | 第二个事务进行更新操作 |
| ----------- | ----------- |  ------------|
| 无 | 立即获得共享锁 | 立即获得独占锁 |
| 共享锁 | 立即获得共享锁 | 等待第一个事务解除共享锁 |
| 独占锁 | 等待第一个事务解除独占锁 | 等待第一个事务解除独占锁 |

### 行级锁
**行级锁是一种排他锁，防止其他事务修改此行**；在使用以下语句时，Oracle 会自动应用行级锁：
1. INSERT, UPDATE, DELETE, SELECT...FOR UPDATE[OF columns][WAIT n | NOWAIT];
2. SELECT...FOR UPDATE 语句允许用户一次锁定多条记录进行更新；
3. 使用 COMMIT 或 ROLLBACK 语句释放锁。

### 表级锁
表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。

最常使用的 MyISAM 和 InnoDB 都支持表级锁定。

表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

### 页级锁
页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。

表级锁速度快, 但冲突多, 行级锁冲突少, 但速度慢，所以采取了这种的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。

- 表级:引擎 MyISAM, 理解为锁住整个表, 锁定期间, 其它进程无法对该表进行写操作, 如果是读锁, 其他进程可以同时读, 如果是写锁, 则其它进程则读也不允许
- 行级:引擎 INNODB, 单独的一行记录加锁, 其它进程还是可以对同一个表中的其它记录进行操作
- 页级:引擎 BDB, 表级锁速度快, 但冲突多, 行级冲突少, 但速度慢, 页级折衷, 一次锁定相邻的一组记录






















