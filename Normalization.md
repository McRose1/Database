# 数据库三范式
范式是具有最小冗余的表结构。

## 1NF（第一范式-列都是不可再分的）
第一范式的目标是确保每一列的**原子性**：如果每一列都是**不可再分**的最小数据单元（也称为最小的原子单元），则满足 1NF

|学生编号|学生姓名|联系方式|
|----|----|----|
|1001|张三|zs@qq.com,13358574829|
|1002|李四|ls@qq.com,13958343259|
|1003|王五|ww@qq.com,15934534523|

问题：联系方式字段可以再分，不是原子性的

应改成：
|学生编号(pk)|学生姓名|email|联系方式|
|----|----|----|----|
|1001|张三|zs@qq.com|13358574829|
|1002|李四|ls@qq.com|13958343259|
|1003|王五|ww@qq.com|15934534523|

## 2NF（第二范式-每个表只描述一件事情）
首先满足第一范式，在此基础上，要求表中**非主键列完全依赖主键，不存在对主键的部分依赖**。

|学生编号(pk)|教师编号(pk)|学生姓名|教师姓名|
|----|----|----|----|
|1001|001|张三|王老师|
|1002|002|李四|赵老师|
|1003|001|王五|王老师|
|1001|002|张三|赵老师|

上面的表虽然确定了主键，但此表会出现大量的冗余，主要涉及到的冗余字段为“学生姓名”和“教师姓名”，出现的冗余的原因在于，学生姓名部分依赖于主键的一个字段学生编号，而没有依赖教师编号；而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。

其实实质上第二范式讲的就是，我们要避免联合主键的出现。

应该拆分成 3 个表

学生信息表
|学生编号(pk)|学生姓名|
|----|----|
|1001|张三|
|1002|李四|
|1003|王五|

教师信息表
|教师编号(pk)|教师姓名|
|----|----|
|001|王老师|
|002|赵老师|

教师和学生的关系表
|学生编号(pk) fk ->学生表的学生编号|教师编号(pk) fk -> 教师表的教师编号|
|----|----|
|1001|001|
|1002|002|
|1003|001|
|1001|002|

上面就是一种“多对多”的设计

## 3NF（第三范式-不存在对非主键列的传递依赖）
首先满足第二范式，在此基础上，满足表中的非主键字段不能传递依赖于的主键字段。

指表中所有的数据元素不但要能唯一地被主键所标识，而且他们之间还必须相互独立，不存在其他的函数关系

|学生编号(pk)|学生姓名|班级编号|班级名称|
|----|----|----|----|
|1001|张三|01|一年一班|
|1002|李四|02|一年二班|
|1003|王五|03|一年三班|
|1004|赵六|04|一年三班|

从上表可以看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键，班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖。解决的办法是将冗余字段单独拿出来建立表，如：

学生信息表
|学生编号(pk)|学生姓名|班级编号(fk)|
|----|----|----|
|1001|张三|01|
|1002|李四|02|
|1003|王五|03|
|1004|赵六|03|

班级信息表
|班级编号(pk)|班级名称|
|----|----|
|01|一年一班|
|02|一年二班|
|03|一年三班|

以上设计是一种典型的“一对多”的设计，“一”存储在一张表中，“多”存储在一张表中，在多的那张表中添加外键指向“一”的一。

## 实际开发
数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终目的要满足客户需求。





